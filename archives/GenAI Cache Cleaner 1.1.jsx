(function () {    // -------- Helpers --------    function getMajorVersion() {        var v = app.version, major = 0;        for (var i = 0; i < v.length; i++) {            var ch = v.charAt(i);            if (ch == ".") break;            var c = ch.charCodeAt(0);            if (c >= 48 && c <= 57) major = (major * 10) + (c - 48);        }        return major;    }    // Extract version parts (e.g., "30.1.0" returns {major: 30, minor: 1, patch: 0, majorMinor: "30.1", full: "30.1.0"})    function getVersionParts() {        var v = app.version;        var parts = v.split(".");        var result = {            major: parts[0] || "0",            minor: parts[1] || "0",            patch: parts[2] || "0",            majorMinor: "",            full: ""        };                result.majorMinor = result.major + "." + result.minor;        result.full = result.major + "." + result.minor + "." + result.patch;                return result;    }    // Try multiple candidate preference folder names and locales (regular, Beta, and Windows x64)    function resolvePrefsFolder() {        var isMac = (File.fs == "Macintosh");        var isWin = (File.fs == "Windows");        var major = getMajorVersion();        var ver = getVersionParts();        var locale = app.locale ? app.locale : "en_US";        // Name variants for folder immediately under Preferences/Adobe (Mac) or %APPDATA%\Adobe (Win)        // Generate variants with different version formats        var nameVariants = [];                // Non-beta variants        nameVariants.push("Adobe Illustrator " + ver.full + " Settings");        nameVariants.push("Adobe Illustrator " + ver.majorMinor + " Settings");        nameVariants.push("Adobe Illustrator " + major + " Settings");                // Beta variants with full version        nameVariants.push("Adobe Illustrator " + ver.full + " Beta Settings");        nameVariants.push("Adobe Illustrator " + ver.majorMinor + " Beta Settings");        nameVariants.push("Adobe Illustrator " + major + ".0.0 Beta Settings");        nameVariants.push("Adobe Illustrator " + major + ".0 Beta Settings");        nameVariants.push("Adobe Illustrator " + major + " Beta Settings");        function tryLocales(baseFolder) {            var locs = [locale, "en_US", "en_GB"];            for (var i = 0; i < locs.length; i++) {                var locF = new Folder(baseFolder.fsName + "/" + locs[i] + "/");                if (locF.exists) return locF;            }            if (baseFolder.exists) return baseFolder;            return null;        }        if (isMac) {            var home = Folder("~").fsName;            var prefRoot = new Folder(home + "/Library/Preferences");            var i, candidate, hit;            for (i = 0; i < nameVariants.length; i++) {                candidate = new Folder(prefRoot.fsName + "/" + nameVariants[i]);                hit = tryLocales(candidate);                if (hit) return hit;            }        } else if (isWin) {            // Prefer %APPDATA% when available, fallback to standard userData parent            var appdata = $.getenv("APPDATA");            var base = appdata && appdata.length > 0 ? appdata : Folder.userData.parent.fsName; // Roaming            var adobeRoot = new Folder(base + "\\Adobe");            var i2, cand2, hit2;            for (i2 = 0; i2 < nameVariants.length; i2++) {                cand2 = new Folder(adobeRoot.fsName + "\\" + nameVariants[i2]);                hit2 = tryLocales(cand2);                // Check for x64 subfolder inside locale                if (hit2) {                    var x64Folder = new Folder(hit2.fsName + "\\x64\\");                    if (x64Folder.exists) return hit2; // If locale exists, return that (main logic uses x64 if found inside below)                    return hit2;                }            }        }        return null;    }    function getGenAIFolder(baseFolder, targetName) {        var directFolder = new Folder(baseFolder.fsName + "/" + targetName);        var x64Folder = new Folder(baseFolder.fsName + "/x64/" + targetName);        if (directFolder.exists) {            return directFolder;        } else if (x64Folder.exists) {            return x64Folder;        } else {            return directFolder;        }    }    function getFolderStats(fld) {        var total = 0, subCount = 0, fileCount = 0;        if (!fld || !fld.exists) return { bytes:0, subCount:0, fileCount:0 };        var stack = [fld];        while (stack.length > 0) {            var cur = stack.pop();            var items = cur.getFiles();            for (var i = 0; i < items.length; i++) {                var it = items[i];                if (it instanceof Folder) { subCount++; stack.push(it); }                else if (it instanceof File) { try { if (it.exists) { total += it.length; fileCount++; } } catch(e){} }            }        }        return { bytes: total, subCount: subCount, fileCount: fileCount };    }    function formatSize(bytes) {        var mb = bytes / (1024*1024);        if (mb <= 0) return "0 MB";        var r = Math.round(mb*10)/10;        if (r < 0.1) r = 0.1;        return r + " MB";    }    // Recursive delete that attempts to remove all children before removing the folder itself    function deleteFolderRecursive(fld) {        var result = { ok: true, deletedFiles: 0, deletedFolders: 0, errors: [] };        if (!fld || !fld.exists) return result;        try {            var items = fld.getFiles();            for (var i = 0; i < items.length; i++) {                var it = items[i];                try {                    if (it instanceof Folder) {                        var sub = deleteFolderRecursive(it);                        result.ok = result.ok && sub.ok;                        result.deletedFiles += sub.deletedFiles;                        result.deletedFolders += sub.deletedFolders;                        if (sub.errors.length > 0) {                            for (var e = 0; e < sub.errors.length; e++) result.errors.push(sub.errors[e]);                        }                        if (it.exists) {                            if (!it.remove()) {                                result.ok = false;                                result.errors.push("Failed to remove folder: " + it.fsName);                            } else {                                result.deletedFolders++;                            }                        }                    } else if (it instanceof File) {                        if (it.exists) {                            if (!it.remove()) {                                result.ok = false;                                result.errors.push("Failed to remove file: " + it.fsName);                            } else {                                result.deletedFiles++;                            }                        }                    }                } catch (remErr) {                    result.ok = false;                    result.errors.push("Error removing: " + it.fsName + " (" + remErr + ")");                }            }            if (fld.exists) {                if (!fld.remove()) {                    result.ok = false;                    result.errors.push("Failed to remove folder: " + fld.fsName);                } else {                    result.deletedFolders++;                }            }        } catch (e) {            result.ok = false;            result.errors.push("Error traversing: " + fld.fsName + " (" + e + ")");        }        return result;    }    // -------- Data --------    var prefs = resolvePrefsFolder();    if (!prefs) { alert("Could not locate the Illustrator Preferences folder (regular, Beta, or x64)."); return; }    var targetNames = ["GenAIImageToCaption","GenAITextToVectors", "GenAIRotateVector", "GenAIRecolor", "GenAIPatterns", "GenAIMultiDiffusion"];    var entries = [];    for (var i = 0; i < targetNames.length; i++) {        var f = getGenAIFolder(prefs, targetNames[i]);        entries.push({ name: targetNames[i], folder: f, present: f.exists, stats: {bytes:0, subCount:0, fileCount:0}, bullet: null, label: null, checkbox: null });    }    // -------- UI --------    var dlg = new Window("dialog", "GenAI Cache Cleaner 1.1");    dlg.orientation = "column"; dlg.alignChildren = ["fill","top"]; dlg.margins = 24; dlg.spacing = 12;    var header = dlg.add("statictext", undefined, "Preferences base: " + prefs.fsName, {multiline:true});    header.alignment = "fill";    var listHeader = dlg.add("group"); listHeader.orientation = "row"; listHeader.alignChildren = ["left","center"];    var selHint = listHeader.add("statictext", undefined, "Click names to open. Check to delete.");    selHint.characters = 48;    var listGroup = dlg.add("group"); listGroup.orientation = "column"; listGroup.alignChildren = ["fill","top"]; listGroup.spacing = 6;    for (var r = 0; r < entries.length; r++) {        var row = listGroup.add("group"); row.orientation = "row"; row.alignChildren = ["left","center"]; row.spacing = 10;        var cb = row.add("checkbox", undefined, "");        var bullet = row.add("statictext", undefined, "\u25CF"); bullet.characters = 1;        var label = row.add("statictext", undefined, ""); label.characters = 56;        entries[r].checkbox = cb; entries[r].bullet = bullet; entries[r].label = label;        (function(ent){            label.addEventListener("click", function(){                try {                    // Open the specific GenAI folder if present, else open the base prefs folder                    var toOpen = ent.folder.exists ? ent.folder : prefs;                    toOpen.execute();                } catch(e){}            });        })(entries[r]);    }    var totalText = dlg.add("statictext", undefined, "", {multiline:true});    totalText.alignment = "fill";    var footer = dlg.add("group"); footer.orientation = "row"; footer.alignChildren = ["right","center"]; footer.spacing = 10;    var deleteBtn = footer.add("button", undefined, "Delete Selected");    deleteBtn.preferredSize = [140,32];    var openPrefsBtn = footer.add("button", undefined, "Open Prefs");    openPrefsBtn.preferredSize = [120,32];    var closeBtn = footer.add("button", undefined, "Close");    closeBtn.preferredSize = [100,32];    // -------- Render --------    function refresh() {        var grandTotal = 0;        for (var i = 0; i < entries.length; i++) {            var e = entries[i];            e.present = e.folder.exists;            e.stats = getFolderStats(e.present ? e.folder : null);            grandTotal += e.stats.bytes;            var line = e.name + " (" + e.stats.subCount + ") " + formatSize(e.stats.bytes);            e.label.text = line;            var dim = (!e.present || (e.stats.subCount === 0 && e.stats.fileCount === 0 && e.stats.bytes === 0));            e.label.enabled = !dim;            try { e.bullet.enabled = !dim; } catch(err){}            e.checkbox.enabled = e.present;            if (!e.present) e.checkbox.value = false;        }        totalText.text = "Total size across all GenAI folders: " + formatSize(grandTotal);    }    refresh();    // -------- Events --------    openPrefsBtn.onClick = function(){ try { prefs.execute(); } catch(e) {} };    deleteBtn.onClick = function() {        // Gather selected targets        var targets = [];        for (var i = 0; i < entries.length; i++) {            var e = entries[i];            if (e.checkbox.value && e.folder.exists) targets.push(e);        }        if (targets.length === 0) {            alert("No folders selected or they do not exist.");            return;        }        // Build confirmation summary        var sumLines = [];        var i2, e2, line;        for (i2 = 0; i2 < targets.length; i2++) {            e2 = targets[i2];            line = "- " + e2.name + " (" + e2.stats.subCount + " items) " + formatSize(e2.stats.bytes);            sumLines.push(line);        }        var msg = "Warning: This will permanently delete the selected folders and their contents.\n\n" +                  "Folders to delete:\n" + sumLines.join("\n") + "\n\n" +                  "Are you sure you want to continue?";        if (!confirm(msg)) return;        // Execute deletions        var report = [];        for (var k = 0; k < targets.length; k++) {            var tgt = targets[k];            var name = tgt.name;            var res;            try {                res = deleteFolderRecursive(tgt.folder);            } catch (ex) {                res = { ok:false, deletedFiles:0, deletedFolders:0, errors:["Unexpected error: " + ex] };            }            var status = res.ok ? "OK" : "FAILED";            var rep = name + ": " + status + " — deleted files: " + res.deletedFiles + ", deleted folders: " + res.deletedFolders;            report.push(rep);            if (!res.ok && res.errors.length > 0) {                var j;                for (j = 0; j < res.errors.length; j++) {                    report.push("  • " + res.errors[j]);                }            }        }        alert("Deletion completed.\n\n" + report.join("\n"));        refresh();    };    closeBtn.onClick = function(){ dlg.close(); };    dlg.center(); dlg.show();})();